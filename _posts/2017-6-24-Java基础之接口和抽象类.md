---
layout: post
title:  "Java基础之接口和抽象类"
date: 2017-06-24 08:30:48
categories: Java基础
tags:  Java
---
* content
{:toc}  
  
Java作为一种纯面向对象的程序设计语言，它的这个面向对象的特点也得益于该语言提供
的抽象类和接口这两大特性，《Think in Java》中提到万物皆对象，而所有的对象它的描
述都是类；然而天然的就有一些类它描述的也不是特别的具体，比如说：动物，对于这样
的描述，我们不知道它所描述的动物是何物，它具有什么特征等，我们因而可以设计它为
一个抽象类，或者是一个接口；而具体的描述只需要继承这个动物的特性即可。




### 抽象类

抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于
这组抽象方法的具体表现形式有派生类来实现。

抽象类存在以下一些特征：  

1. 抽象不能被实例化，它的实例化工作需要交给其派生类来实现。  
2. 抽象类中的所有的抽象方法在子类中必须重写。  
3. 只要有抽象方法，该类必须设计成抽象类。  
4. 抽象类中可以有具体的方法，也可以没有具体的方法。  
5. 子类的作为抽象类时，不能存在和父类同名的抽象方法。  
6. abstarct 声明的类是抽象类，为继承而生，相反final修饰的类是不允许继承的，不能  
   同时修饰同一个类。  
7. abstract 不能和private ，static, final ,native 修饰同一个方法。  

``` java

abstract class Animal{
    public abstract void cry();
}

class Cat extends Animal{

    @Override
    public void cry() {
        System.out.println("猫叫：喵喵...");
    }
}

class Dog extends Animal{

    @Override
    public void cry() {
        System.out.println("狗叫:汪汪...");
    }

}

public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat();
        Animal a2 = new Dog();
        
        a1.cry();
        a2.cry();
    }
}

```

创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译
器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法
沿着继承层次结构向上移动。《摘录：Think in Java》

### 接口

接口中通常是对一些抽象的描述，通过声明一系列方法作为一个接口框架，具体的接口实
现留个子类提供。当然存在一些常量接口，不过在《effective Java》书中作者提出可以
考虑使用enum 枚举来替他这种常量接口。接口本身而言他不是类，因而不能通过 类似于这
样的方式来实现一个接口如：`new Runnable()`。
接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时
实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示
该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需
要声明它是如何工作的”。
接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一
个父类，但是接口不同，一个类 **(可以是抽象类)**  可以同时实现多个接口，不管这些接口之间有没有关系，
所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既
可以保证数据安全性又可以实现多重继承。

接口在使用过程中需要注意的地方：  

1、 个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你
可以显示的声明为protected、private，但是编译会出错！

2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动
变为为public static final。可以通过类命名直接访问：ImplementClass.name。

3、接口中不存在实现的方法。

4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类实现某接口可以不用实现。

5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（
 refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现
了某个特定的接口。例如：if(anObject instanceof Comparable){}。

6、在实现多接口的时候一定要避免方法名的重复。

### 接口和抽象类的区别

接口和抽象类存在着很多共同点，甚至有些时候可以互换（通常是不这么做的）它们的存
在都有各自的特点，下面是它们在语法层次和设计层次上的一些区别。

#### 语法层次区别

在语法层次，抽象类和接口各自有自己的定义如下：

**抽象类**

``` java

public abstract class TestDemo{

    public abstract void method();
    public void method2(){
        // 实现 
    }
}

```

**接口**

``` java

interface TestDemo{
    public static final String STRING_A = "0"; 
    void method1();
    public void method2();
    protected void method3();//protected / private not allowed here

}


```
抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法
，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口
中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象
类的特殊化。对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），
但是却可以实现多个接口。

### 设计层区别

上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用
好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它
们的本质所在。一般来说他们存在如下三个不同点：

1、抽象层次不一样

> 抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属
>性、行为，但是接口却是对类局部（行为）进行抽象。

2、跨域不同

> 抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从
> 子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它
> 的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备
> 叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用
> 一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派
> 生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则
> 不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义
> 的契约而已。

3、设计层次不同

> 对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则
> 不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么
> 时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物
> 类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们
> 的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，
> 比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我
> 们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自
> 顶向下设计出来的。 

为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：  

[http://blog.csdn.net/ttgjz/article/details/2960451](http://blog.csdn.net/ttgjz/article/details/2960451)  

我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽
象类和接口来定义这个抽象概念：

抽象类：  

``` java

abstract class Door{
    abstract void open();
    abstract void close()；
}

```

接口：

``` java

interface Door{
    void open();
    void close();
}

```

至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口
方式定义Door，这里发现两者并没有什么很大的差异。

但是现在如果我们需要门具有报警的功能，那么该如何实现呢？

**解决方案一**：给Door增加一个报警方法:clarm();

``` java

abstract class Door{
    abstract void open();
    abstract void close();
    abstract void alarm();
}

// 或者

interface Door{
    void open();
    void close();
    void alarm();
}

```

这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)
，在Door的定义中把Door概念本身固有的行为方法和另外一个概念"报警器"的行为
方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为"报警
器"这个概念的改变而改变，反之依然。
ISP准则是：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要
好。  
一个类对另外一个类的依赖性应当是建立在最小的接口上的。  
一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并  
在一起，形成一个臃肿的大接口，这是对角色和接口的污染。

**解决方案二**

既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定
义在两个代表两个不同概念的抽象类里面，定义的方式有三种：

1. 两个都使用抽象类来定义
2. 两个都使用接口来定义
3. 一个使用抽象类一个使用接口来定义

由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反
映了你对问题域本质的理解。  

第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警
的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质
是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能
够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下： 

``` java

abstract class Door{
    abstract void open();
    abstract void close();
}

interface Alarm{
    void alarm();
}

class AlarmDoor extends Door implements Alarm{
    void open(){}
    void close(){}
    void alarm(){}
}

```

这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计
意图。其实抽象类表示的是"is-a"关系，接口表示的是"like-a"关系，大家在选择时可以
作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在
概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。

### 总结

1、抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。

2、在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不
 可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽
象的。

3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。
只有对问题域的本质有良好的理解，才能做出正确、合理的设计。
