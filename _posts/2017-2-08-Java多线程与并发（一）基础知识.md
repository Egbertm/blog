---
layout: post
title:  "Java多线程与并发（一）基础知识"
date:   2017-2-08 23:06:05
categories: Java多线程
tags:  Java多线程 并发
---
* content  
{:toc}  

### Java进程与线程  
目前大多数的操作系统系统都是多任务的操作系统，一个任务通常对应了一个程序，而每个程序需要系统为它独立的分配资源，它在操作系统里被称为是一个独立的进程。而一个程序的运行，它的内部可能有多个执行流。每个执行流是个线程，它依托于进程而存在的。以下是相关概念的定义：  




进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体  
线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源  
并发性（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果  
并行性（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行；  

进程的三大特性：  

**独立性**：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。  

**动态性**：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念，进程具有自己的生命周期和各种不同的状态，这些概念在程序中部是不具备的。  

**并发性**：多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响  

进程之间不能共享内存，但线程之间共享内存非常容易，系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高，Java语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。  
但是多线程之间并发势必会带来线程之间的安全性问题：  

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。

如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。

### 同步与阻塞等相关概念  
同时又涉及到了在并发编程以及多线程编程的几大概念：同步与异步、阻塞与非阻塞  

同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；  

异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待  

它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待  

阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；  

非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。  

阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。

### Java多线程  

java 中实现多线程的方式，归根结底是继承一个Thread类或者是实现一个Runnable接口，但是Java 的单继承机制是的大多数的时候倾向于使用实现一个Runnable接口。 

多线程的优点：  

1）资源利用率更好  
2）程序设计在某些情况下更简单  
3）程序响应更快  

多线程的代价：  

1）设计更复杂  
虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复  。

2）上下文切换的开销  
当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生  

### Java线程池的使用  

Java通过Executors提供四种线程池，分别为：

newCachedThreadPool

创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。  

newFixedThreadPool   

创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。  

newScheduledThreadPool   

创建一个大小无限制的线程池。此线程池支持定时以及周期性执行任务。  

newSingleThreadExecutor  

创建一个单线程的线程池。此线程池支持定时以及周期性执行任务。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。  

### Java多线程中的各种状态转换  

新状态: 一个新产生的线程从新状态开始了它的生命周期。它保持这个状态知道程序start这个线程。

运行状态:当一个新状态的线程被start以后，线程就变成可运行状态，一个线程在此状态下被认为是开始执行其任务

就绪状态:当一个线程等待另外一个线程执行一个任务的时候，该线程就进入就绪状态。当另一个线程给就绪状态的
线程发送信号时，该线程才重新切换到运行状态。

休眠状态: 由于一个线程的时间片用完了，该线程从运行状态进入休眠状态。当时间间隔到期或者等待的时间发生
了，该状态的线程切换到运行状态。

终止状态: 一个运行状态的线程完成任务或者其他终止条件发生，该线程就切换到终止状态。

### 参考文献  

[http://ifeve.com/java-concurrency-thread-directory/](http://ifeve.com/java-concurrency-thread-directory/ "http://ifeve.com/java-concurrency-thread-directory/")  

[http://www.importnew.com/16453.html](http://www.importnew.com/16453.html "http://www.importnew.com/16453.html")   

[http://www.cnblogs.com/dolphin0520/p/3916526.html](http://www.cnblogs.com/dolphin0520/p/3916526.html "http://www.cnblogs.com/dolphin0520/p/3916526.html")  

[http://www.cnblogs.com/luxiaoxun/p/3870265.html](http://www.cnblogs.com/luxiaoxun/p/3870265.html "http://www.cnblogs.com/luxiaoxun/p/3870265.html")  


