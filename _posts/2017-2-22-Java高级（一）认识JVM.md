---
layout: post
title:  "Java高级（一）认识JVM"
date:   2017-2-22 23:06:05
categories: Java高级
tags:  Java高级 JVM
---
* content  
{:toc}  

### 1. Java 发展的几个重要的时间节点

Java的前身是一个被称为Oak的语言，是由Patrick Naughton、MikeSheridan及James Cosling设计出来的，最开始是为了解决在电子产品的控制问题。并希望通过一种跨平台的方式实现，他们也尝试了使用C++开发，但是一直无法克制编译器的问题。那个时候自己开发的Oak语言已经具备了安全性，及网络通信、面向对象等。后来发现Oak已被人注册，所以改成了Java，一直到现在流传至今。  




1. 1995年Java 登录历史的舞台  
2. 1996年发布了Java1.0版本  
3. 1998发布了java1.2版本，同时开始将java的阵营分成三大块，JavaSE，JavaME,JavaEE.  
4. 2000,JDK1.3发布，HotSpot作为Java默认的虚拟机。  
5. 2004，JDK1.5发布，此版本的Jdk发生了还大的改变，java语言做了很大的该进，添加了诸如泛型、注解、自动装箱与拆箱、枚举，可变参数，增强for循环等。  
6. 2011年JDK1.7发布正式启用了G1作为垃圾回收器。  
7. 2014年JDK1.8发布，添加了函数式编程Lambda。  
如今虚拟机也是有很多种，像一些大公司自己实现了java虚拟机，如IBM的J9虚拟机，BEA的JRockit虚拟机，如今已经被Oracle收购。现在最大的虚拟机使用可能是Hostspot虚拟机吧。  

### 2. java虚拟机的基本结构
java 虚拟的机它包括有java字节码的执行引擎，垃圾回收器，java堆，java栈，方法区，程序计数器，本地方法栈，还有类加载系统下如图所示。  
![http://o886hn2n8.bkt.clouddn.com//java_advance/JVM%E7%BB%93%E6%9E%84%E5%9B%BE.png](http://o886hn2n8.bkt.clouddn.com//java_advance/JVM%E7%BB%93%E6%9E%84%E5%9B%BE.png)

java 类加载器负责从文件系统中加载Class的信息，加载的信息一般也存放在方法区。方法区除了有这些了类的基本信息，还包括常量池。java堆是储存java对象的地方，它是一块可以由程序员直接操控的地方，堆的空间对于所有的线程是共享的。本地内存的访问是在Java NIO出现后，可以通过JavaApi直接操作系统内存。垃圾回收器也是java的一个核心组件，也是经过了若干次的发展而来的，对于垃圾回收器，有很多垃圾回收算法，诸如：标记清除，标记压缩，copying复制，分代，分区等等。不同的垃圾回收策略，对java虚拟机的性能影响也是不一样的。也没有一种一劳永逸的方法可以解决java虚拟机的效率问题。java栈是一段不大的内存空间，每个java线程创建时，都会在创建一个线程的java栈中，该栈中存储着一些局部变量、方法参数、还有一些方法的调用等。本地方法栈和java栈一样，只是本地方法栈是用于本地方法的调用的。

### 2.1 java堆  
Java堆是Java虚拟机管理的最大的一块内存。Java堆被所有的线程共享，它在虚拟机启动时创建。次内存区域的唯一目的就是存放对象的实例，几乎所有的对象实例都存放在这里。在Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配。  
Java堆是垃圾回收器的主要管理区域。采用的是分代收集算法，java堆可以具体的分为新生代、老年代、新生代又可以分为Eden区间、From区间、To区间等。从内存的分配角度，线程共享的Java堆中可以划分出多个线程私有的内存缓冲区。java堆可以处在物理上不连续的内存空间，只要在逻辑上连续即可。

### 2.2 java栈  
1. 虚拟机栈是线程共享的它的生命周期与线程相同。虚拟机描述的是Java方法执行的内内存模型：每个方法都会创建一个栈帧用于存储局部变量表、操作数、动态链接、方法出口等信息。方法的调用与结束对应着一个栈帧的入栈和出栈。  
2. 本地方法帧，它是与虚拟机栈发挥同样的作用，它们的区别在于虚拟机栈是为Java 方法提供服务的，而本地方法栈是为Native方法提供服务的。现在诸如在HotSpot上已经将虚拟机栈和本地方法栈合并了。
### 2.3 方法区  
方法区和Java 堆一样是各个线程共享的一块区域，它存储的是虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等。现在在Java1.8上有个元数据区以前被称为持久区，就是方法区。

### 3 常用的Java虚拟机的参数

#### 3.1 虚拟机的跟踪参数
1. -XX:PrintGC 打印GC日志
2. -XX:PrintGCDetails 打印GC日志的详细信息。  

```
    
    Heap
     PSYoungGen      total 18944K, used 2622K [0x00000000eb300000, 0x00000000ec800000, 0x0000000100000000)
      eden space 16384K, 16% used [0x00000000eb300000,0x00000000eb58fab0,0x00000000ec300000)
      from space 2560K, 0% used [0x00000000ec580000,0x00000000ec580000,0x00000000ec800000)
      to   space 2560K, 0% used [0x00000000ec300000,0x00000000ec300000,0x00000000ec580000)
     ParOldGen       total 44032K, used 0K [0x00000000c1800000, 0x00000000c4300000, 0x00000000eb300000)
      object space 44032K, 0% used [0x00000000c1800000,0x00000000c1800000,0x00000000c4300000)
     Metaspace       used 2652K, capacity 4486K, committed 4864K, reserved 1056768K
      class space    used 286K, capacity 386K, committed 512K, reserved 1048576K
    

```  
  
以上是虚拟机打印出来的基本堆信息，有年轻代的总大小，使用是多少，有Eden区的空间以及使用率是多少，from 和 to 的空间一直。老年代的大小，以及在JDK1.8之后的元数据去空间大小，以前叫持久代。  
3 -XX:TraceClassLoading 跟踪类的加载  
4 -XX:TraceClassUnloading 跟踪类的卸载  

#### 3.2配置java堆的参数  
java进程启动的时候会为虚拟机会分配一块初始的堆空间，可以使用参数-Xms来指定允许分配的初始化的堆空间。当初始堆的内存空间使用高于堆空间的70%是会自动扩展堆的空间至-Xmx指定的允许分配给堆的最大的空间。如在jvm启动时配置：
`-Xms256M -Xmx256M`表示初始的堆内存和最大的堆内存是一样大的这样的一个好处是将减少垃圾回收器的次数，从而提高程序的性能。`-Xmn`可以用于新生代的配置，设置一个较大的新生代的大小，会相应的减少年老代的大小。一般而言配置新生代的大小是年老代的1/3或者是1/4.`XX:SurvivorRatio`该命令主要是配置Eden和from/to的空间比例一般SurvivorRatio=eden/from=eden/to。`-XX:NewRatio`是设置老年代和年轻代的比值。通过如下一张图可以看清他们之间的关系  
![http://o886hn2n8.bkt.clouddn.com//java_advance/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png](http://o886hn2n8.bkt.clouddn.com//java_advance/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)


。
除了以上的一些基本配置外，还可以对方法区配置:`-XX:PermSize`初始化方法区的大小，`-XX:MaxPermSize`允许的最大的永久区，在JDK1.8后，使用的元数据区，可以用`-XX:MaxMetaspaceSize`指定永久区的最大值。对于栈的配置可以使用`-Xss`来指定线程栈的大小。倘若要配置直接使用内存可以使用参数`-XX:MaxDirectMemorySize`进行设置，如果不设置的化，最大的的使用空间的大小是-Xmx一样。

### 4  垃圾回收机制

#### 4.1 垃圾回收的算法
垃圾回收是对堆而言的一种释放内存的说法，在一些其他的语言中如C++中对于内存的管理这一方式都是交给程序员管理，程序员负责对程序中内存的分配与回收，这样无意中就加重了程序员的负担，还容易造成内存溢出等问题，而Java语言最大的优势是，由JVM管理内存的回收，让程序员把跟多的精力放在业务逻辑的处理上。既然JVM管理内存，那怎样知道对象什么时候可以回收，什么情况下内存不能回收。这就涉及到了jvm垃圾回收的算法。
1引用计数法
这是一个比较老的处理方式，对于引用计数，也就是说对象A被对象B引用那么对象A的引用计数就增加一，当引用失效后就相应的减一，这样对与简单的管理是可以，但是对于一些诸如循环引用的时候还是不能很好的工作，引起内存泄漏。
2 标记清除法
标记清除法主要有两个阶段，第一阶段是标记可达对象，可达对象就是通过根对象能够进行引用搜索，最终可以到达引用的对象。第二阶段是清除阶段，这个阶段是对于那些不可以达的对象进行清除;而不可达对象，就是在根对象上不能通过引用搜索达到引用的对象。这样导致的一个最大的问题是导致了很多的内存碎片，不利于大对象的内存分配。

3复制算法，对于该算法它的核心是在原有的内存中分配两个大小一样的内存空间，每次只用其中的一块，在垃圾回收时将所有存活的对象复制到同一快内存中，对于另一块内存则可以全部清空。但是复制算法也在面对存活对象数多的情况下效率低的问题。目前在JVM中对于新生代中的Survision中就是使用的这个原理。
4 标记压缩法
标记压缩法是一种在老年代垃圾回收的算法，它是在标记清除法的基础上进行了一些优化而实现的，它在标记阶段依然是一样的，在第二阶段主要是将存活的对象压缩到内存的一端，这样就不会导致太大的内存碎片了。对于清除对象的内存也只需要对压缩边界以外的地方进行清除即可。
5 分代算法
现在的JVM采用的年轻代和年老代就是使用的这种算法，借鉴了前面的复制算法，标记清除，标记压缩算法。而由于年轻代的垃圾回收频率要高于年老代的垃圾回收频率，对于这种高频的垃圾回收策略，为年老代设置了一个cardtable的数据结构，能够局部的回收年老代中那些持有新生代对象的引用，提高了算法的效率。
6.分区算法
是在对象的生命周期中，将堆的内存空间划分成连续的不同的小区间，对每一个小区间进行单独的回收，管理和使用。目的是为了解决在垃圾回收是由GC导致的停顿。  

#### 4.2垃圾回收的对象  

垃圾回收的对象是那些不可触及的对象，对于有些触及的对象，在被赋值为Null后并不一定被回收，还存在在finalize中复活的可能。对于引用的可触及的强度可以分为以下几种  
强引用，如 `String str = new String("Hello")；`  
软引用，比强引用弱一点的引用，当堆的空间不足时才会被回收。在Java中用java.lang.ref.SoftReferrnce类实现  
弱引用，是一种比软引用弱的引用。被发现立即回收，在java中通过java.lang.ref.WeakReference类实现。  
虚引用，和没有引用一样，为的是跟踪垃圾回收的过程，Java.lang.ref.PhantomReference.  

### 参考文献

[http://blog.csdn.net/zhangjg_blog/article/details/20380971](http://blog.csdn.net/zhangjg_blog/article/details/20380971 "http://blog.csdn.net/zhangjg_blog/article/details/20380971")  
[http://www.cnblogs.com/java-my-life/archive/2012/08/01/2615221.html](http://www.cnblogs.com/java-my-life/archive/2012/08/01/2615221.html "http://www.cnblogs.com/java-my-life/archive/2012/08/01/2615221.html")