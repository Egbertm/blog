---
layout: post
title:  "算法之链表"
date: 2017-08-13 23:03:43
categories:
tags:  tags
---
* content
{:toc}  
  
在数据的存储结构上，有的用数组存储，有的则选择用链表存储；那么就会问到底什么时候
选择何种数据结构？以及为什么选择这种数据结构？我们知道在学数据结构的时候，数组也
是最开始学的，它存储数据很方便，同时也只要获取数组的下标ID就能够得到该元素。而到
学习链表的时候，最开始的是链表的遍历了，需要从链表头到尾的遍历；而在增加元素的时
候直接插入到最后一个节点的后面就可以了。




### 数组和链表

其实针对这两类数据存储结构都有各自的优缺点，数组的优点是它的元素的获取比较方便，
而由于数组被分配在物理连续的地址上在初始化的时候已经确定了数组的长度，所以为数
组增加元素时需要重新增加数组的长度,并把原来的数组重新拷贝到新的数组里面，在
Java里面ArrayList底层的存储结构就是数组，有一个初始化的容量大小，同时也存在多个
构造函数，可以指定数组的负载因子，当达到这个容量的时候，就对数组扩容。链表也是很
常用的数据结构，它是逻辑上连续的内存，并不要求在物理上内存地址也连续,它对于数据
的插入和删除要由于数组，查找上不如数组方便。下面介绍一些与链表有关的算法。

### 链表有关的算法

链表的结构：

``` java
public class ListNode{

public int val;
public ListNode next;
public ListNode(int value){this.val = value};

}
```

1、递归遍历链表

``` java

    public static void forEachListNode(ListNode h){
    
        if (h == null){
        
            return;
        }
        
        System.out.println(h.val); //前序遍历
        forEachListNode(h.next);
        System.out.println(h.val); //逆序遍历链表
    }
```
2、链表的到插法

``` java
    public static ListNode aheadInsert(ListNode h){

        ListNode  ht = new ListNode(0);
        ListNode p1 = null;

        if (h == null){
            return null;
        }
        ht.next = h;
        h = h.next;
        p1 = h;
        ht.next.next = null;

        while(h!=null){
            
            p1 = h.next;
            h.next = ht.next;
            ht.next = h;
            h = p1;
            
        }
        return ht.next;
    }
```

3、求两个链表的第一个公共节点，无则返回null。

``` java

    public static ListNode findFirstCommonNode(ListNode head1, ListNode head2) {
        int length1 = getListLength(head1);
        int length2 = getListLength(head2);

        int diff = length1 - length2;
        ListNode longListHead = head1;
        ListNode shortListHead = head2;

        if (diff < 0) {
            longListHead = head2;
            shortListHead = head1;
            diff = length2 - length1;
        }

        for (int i = 0; i < diff; i++) {
            longListHead = longListHead.next;
        }

        while (longListHead != null && shortListHead != null && longListHead != shortListHead) {
            longListHead = longListHead.next;
            shortListHead = shortListHead.next;
        }

        return longListHead;
    }
```

4、合并两个排序链表

``` java

    public static ListNode merge(ListNode head1, ListNode head2) {
        if (head1 == null) {
            return head2;
        }
        if (head2 == null) {
            return head1;
        }
        ListNode root = new ListNode();
        ListNode pointer = root;
        while (head1 != null && head2 != null) {
            if (head1.value < head2.value) {
                pointer.next = head1;
                head1 = head1.next;
            } else {
                pointer.next = head2;
                head2 = head2.next;
            }
            pointer = pointer.next;
        }

        if (head1 != null) {
            pointer.next = head1;
        }
        if (head2 != null) {
            pointer.next = head2;
        }
        return root.next;
    }

```
5、找到链表环的入口节点,这里采用的是双指针法，一个指针走一步，另一个走两步；这两
个指针肯定会在环的一点相遇，这是让一个指针从头开始一下一步遍历，另一个指针也一下
一步移动，相遇点即为入口点。

``` java
    public static ListNode meetingNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                break;
            }
        }
        if (fast == null || fast.next == null) {
            return null;
        }
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }

```

对于链表的操作关键是代码的实现，真正的涉及到算法的比较少，需要考虑链表的指向以及
指针的移动；还有一些其它的高频算法面试题，比如:复杂链表的复制，二叉搜索树转双向
链表的等等。

