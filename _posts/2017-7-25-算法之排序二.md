---
layout: post
title:  "算法之排序二"
date: 2017-07-25 11:13:03
categories: 算法
tags:  排序
---
* content
{:toc}  
  

前面一篇介绍了时间复杂度为平方级的三种排序算法，接下来看看一些时间复杂度低于平
方级的排序算法，这篇介绍一下：堆排序和合并排序算法。




### 堆排序

**堆的定义**

二叉堆满足二个特性：

1. 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。

2. 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆, 下图展示(5,3,7,4,9,2,8)它们的大顶堆及小顶堆如下图：

``` java
               9                      2                 
              / \                    / \                
             /   \                  /   \               
            5     8                3     5              
           / \   / \              / \   / \             
          4   3 2   7            4   9 7   8            
           (大顶堆)                (小顶堆)                    
```

对于堆排序，重点在与怎么调整堆，从什么位置调整；解决了这两个问题，自然也就把堆
排序的算法写出来了，怎么调整堆：不论是大顶堆还是小顶堆，这堆的它的存储结构一般
用数组来存，而数组我们知道它连续的若干个元素可以得到一颗类似与满二叉树的结构，
因此对于满二叉树，我们可以确定的是 i=n/2-1，l=2*i+1,r=2*i+2,这三个点是最后的一
个子树结构，因此对与建堆的开始节点我们可以选择最后一个子树结构的父节点开始,也就
是i = n/2-1这个节点，在这三个元素中找到最小的一个元素与父元素交换，当遍历到上层
节点的时候，比如到第一个节点的时候，修改了堆顶元素，而这个操作势必影响到堆的结
构，因此对于修改的那个节点的子树需要重新构造堆的结构，这种类似于递归的过程，但
是这里并没有用到栈这样的数据结构，统一用数组的下标(j<n)控制循环，重建堆结构。下
面是整体代码如下：

``` java

public class Heapsort{

    public static void MinHeapfixDown(int []a, int i, int n){
        int temp = a[i];
        int j = 2*i + 1; //左节点
        while (j<n){
        
            if (j+1<n && a[j+1]<a[j]){
            
                j++;
            }
            if (a[j]>temp){
            
                break;
            }

            a[i] = a[j];
            i =j; // 当前节点为下层节点的父节点
            j = 2*i +1;
        }
        a[i]=temp;
    }
    public static void MinHeapfix(int []a,int n){
    
        for (int i = n/2-1; i >= 0; i--) {
            MinHeapfixDown(a,i,n);
        }

    }
    public static void MinHeap(int []a,int n){

        MinHeapfix(a,n);

        for (int i = n-1;i>=0;i--){
        
            // System.out.println(1);
            swap(a,0,i);
            MinHeapfixDown(a,0,i);
           // System.out.println(a[0]);
        }
    }
    public static void swap(int []a,int i, int j){
    
        // int temp =0;
        // temp =a[i];
        // a[i] = a[j];
        // a[j] = temp;
        if (a[i]!=a[j]){
            a[i]^=a[j];
            a[j]^=a[i];
            a[i]^=a[j];
        }
    }
    public static void main (String[] args) {

        int []a = new int[]{5,3,7,4,9,2,8};
        MinHeap(a,7);

        for (int i = a.length-1; i >=0; i--) {
            System.out.print(a[i]+" ");
        }
        
    }
} 

```
堆排序它的时间复杂度是N(N*logN),空间复杂度是O(N);

### 合并排序

合并排序的核心思想是分治，实现的方式借助递归能够写出较为精炼的代码，还是上面的
一组数据a(5,3,7,4,2,9,8),对于分治的化，先把这数组分成两份，
a1(5,3,7),a2(4,2,9,8),按照递归的思路对子数组也照样分出两个，最后数组中只有一个
元素时我们知道对于一个元素的数组可以认定它是有序的，因此可以通过回推了，直到整
个数据有序，数组的时间复杂度是O(N*logN),空间复杂度是O(N);

``` java
                        a(5,3,7,4,2,9,8)                             
                          /         \                
                         /           \               
                        /             \              
                    a(5,3,7,4)        a(2,9,8)                    
                     /     \            /  \            
                    /       \          /    \           
                a(5,3)    a(7,4)    a(2,9) a(8)                     
                /   \      /  \       /  \              
            a(5)   a(3)  a(7) a(4)  a(2) a(9)                    

```

对于合并排序最重要的是如何在两个排好序中的数组中得到一个合并之后的排序数组，可
通过如下代码实现：

``` java

public class Mergesort{

    public static void mergearray(int []a, int first,int mid, int last,int []temp){

        int i = first, j = mid + 1;  
        int m = mid,   n = last;  
        int k = 0;  

        while (i <= m && j <= n)  
        {  
            if (a[i] <= a[j])  
                temp[k++] = a[i++];  
            else  
                temp[k++] = a[j++];  
        }  

        while (i <= m)  
            temp[k++] = a[i++];  

        while (j <= n)  
            temp[k++] = a[j++];  

        for (i = 0; i < k; i++)  
            a[first + i] = temp[i];  
    }

    public static void merges(int []a,int first ,int last,int []temp){

        if (first<last){

            int mid = (first+last)/2;
            merges(a,first,mid,temp);
            merges(a,mid+1,last,temp);
            mergearray(a,first,mid,last,temp);
        }
    }
    public static boolean mergeSort(int []a, int n){

        int []temp = new int[n];
        if (temp == null){

            return false;
        }
        merges(a,0,n-1,temp);
        return true;
    }
    public static void main (String[] args) {

        int []a= new int[]{5,3,7,4,9,2,8};

        mergeSort(a,7);
        

        for (int i = 0; i < a.length; i++) {

            System.out.println(a[i]);
            
        }

    }
} 

```

