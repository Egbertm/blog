---
layout: post
title:  "Java基础之反射动态代理"
date: 2017-06-20 10:42:57
categories: Java基础
tags:  java
---
* content
{:toc}  
  

Java作为动态性语言它的强大之处有很多，其中反射就是它的一大特性；Java的反射API能
够帮助程序员在程序运行时动态的获取一个类的域和方法，也能够动态的创建一个对象。
只要有了java.lang.Class类的对象，就能够获取类的构造方法，域和方法。对应的Class方
法有getConstructor(),getField(),getMethod()。这三个方法还有相应的getDeclaredXXX
版本，区别在于getDeclaredXXX版本的方法只会获取该类自身所声明的元素，而不会考虑继
承下来的。Constructor、Field和Method这三个类分别表示类中的构造方法、域和方法。




### java 反射机制

1、获取类Class对象  

1) A.class ：不会加载类，也不会执行静态代码段；

2) Class.forName("cn.test.reflect.A") ：要求JVM查找并加载指定的类，也就是说
JVM会执行该类的静态代码段；

3) new A().getClass() ：通过对象获取class

2、反射创建对象

1)通过默认的构造函数创建Java对象：  
Class<?> obj = Class.forName("ObjectName").newInstace();

2)通过指定构造函数创建Java对象：  
Class<?> obj = Class.forName("ObjectName");  
Constructor<?> []cons = obj.getConstructors();  
Object** o = (Object**)cons[2].newInstance("p1","p2");  

3)Class 类常用的方法：

　  ▶ getName() ：获得类的完整名字；

　  ▶ getSuperclass() ：获得类的父类；

　  ▶ newInstance() ：通过类的不带参数的构造方法创建这个类的一个对象；

　  ▶ getFields() ：获得当前类和父类中的public类型的所有属性；

　  ▶ getDeclaredFields() ：获得当前类（不包含父类）声明的所有属性，包括private
和public；

　　  注：对于某个属性field，设置field.setAccessible(true)，即可访问private的属
性值，如field.get(obj)

　  ▶ getMethods() ：获得前类和父类中public类型的所有方法；

　  ▶ getDeclaredMethods() ：获得当前类（不包含父类）声明的所有方法，包括private
和public；

　  ▶ getMethod(String name, Class[] parameterTypes) ：获得类的指定方法，name参
数指定方法的名字，parameterTypes 参数指定方法的参数类型;

　  ▶ getConstructors() ：获得当前类的public类型的构造方法；

　  ▶ getDeclaredConstructors() ：获得当前类的public和private类型的构造方法；

　  ▶ getConstructor(Class[] parameterTypes) ：获得类的特定构造方法，
parameterTypes 参数指定构造方法的参数类型；

　  ▶ getInterfaces() ：获得实现的接口；

　  ▶ getSuperclass() ：获得继承的父类；

``` java
interface People {

    public void sayHello();
}

class Student implements People {

    private String name;
    private String age;
    private String statu;


    public void setName(String name){
    
        this.name = name;
    }
    public void setAge(String age){
    
        this.age = age;
    }
    public void setStatu(String st){
    
        this.statu = st;
    }
    public String getAge(){
    
        return age;
    }
    public String getName(){
    

        return name;
    }

    public String getStatu(){
    
        return statu;
    }
    @Override
   public void sayHello(){
   
       System.out.println("I am "+statu+" My name is"+name+" age is "+age);
   } 
   @Override
   public String toString(){
   
       return "statu: "+statu+"name: "+name+"age: "+age;
   }
} 

import java.util.*;
import java.lang.reflect.*;
public class ReflctTest{
    public static void main (String[] args) {
        Class<?> cla_stu = null;
        Class<?> cla_stu1 = null;
		try {
			cla_stu = Class.forName("Student");
            cla_stu1 = Class.forName("Student"); 
            Student stu1 = new Student();
            System.out.println(cla_stu == stu1.getClass());
            System.out.println(cla_stu == cla_stu1); // true 类别对象是唯一的。
			Student stu = (Student)cla_stu.newInstance();
            Method method = cla_stu.getDeclaredMethod("setName",String.class);
            method.invoke(stu,"Girl");
            Method method2 = cla_stu.getMethod("getName");
	        System.out.println("Myname:"+method2.invoke(stu));
            Method method3 = cla_stu.getMethod("sayHello");
            method3.invoke(stu);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
} 

```
> Output:
> Press ENTER or type command to continue  
> true  
> true  
> Myname:Girl  
> I am null My name isGirl age is null  

通过例子我们发现任何一个类，它都有对应的唯一的一个Class类，用于存储类的一些基本
信息，这也是在JVM允许在运行时期检查类的信息也就是通过反射来获取类的信息。上面的
例子也介绍了通过类名 `Strudent` 创建类的例子，也展示了怎样通过getMethod获取对象
的方法，对于执行method方法，在反射的Method类里面有个invoke方法，提供对生产的对象
的方法的调用，这一机制在很多机制中都使用到了，如动态代理，包括一些像Spring这样的
框架底层的实现也基本上是使用反射和动态代理的。

### Java动态代理

Java动态代理是在操作一些对象，希望该对象在执行业务方法时执行一些辅助性的额外的方
法，如在对数据的存储操作时，希望能够在存储前后能够执行一些日志操作等。当然这里之
所以用动态代理而不是直接修改类的源码，就是方便系统的扩展性。而实现也需要用到前面
所讲到的反射了，因为代理对象需要在运行时期获得被代理对象的业务方法。并执行该方法
。

1、JDK代理

JDK代理需要用到一个了Proxy和一个接口InvocationHandle接口。其中代理类Proxy需要继
承InvocationHandle接口。  

1) InvocationHandle 接口：  
``` java
public interface InvocationHandler { 
　　public Object invoke(Object proxy,Method method,Object[] args) throws Throwable; 
} 
```
参数说明：Object proxy：指被代理的对象；② Method method：要调用的方法；③ Object[] args：方
法调用时所需要的参数；

2) Proxy类：用于完成代理的操作类。

``` java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,
InvocationHandler h) throws IllegalArgumentException 
```
参数说明：① ClassLoader loader：类加载器；  
② Class<?>[] interfaces：得到全部的接口；  
③ InvocationHandler h：得到InvocationHandler接口的子类实例 ；  

``` java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class StudnetProxy implements InvocationHandler{
    
    private Object target;
    public Object getInstance(Object target){
    
        this.target = target;
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }
    @Override
    public Object invoke(Object proxy,Method method,Object[] args) throws Exception{
    
        Object result = null;
        System.out.println("方法前");
        result = method.invoke(target,args);
        System.out.println("方法后");
        return result;
    }
    public static void main (String[] args) {
        StudnetProxy stuP = new StudnetProxy();
        People p = (People)stuP.getInstance(new Student());
        p.sayHello("Tom");
    }
} 

```
