---
layout: post
title:  "算法之排序三"
date: 2017-07-30 20:42:42
categories: 算法
tags: 排序 
---
* content
{:toc}  
  
在排序算法领域内，快速排序算法，听这个名字就感觉这个算法的排序效率高，事实上它
和前面的两个算法，堆排序、合并排序一样他们的时间复杂度都是O(N*logN)
, 而且快速排
序也有分治的思想在里面，




### 快速排序

算法的核心就是找准每个元素的位置，使得小于该位置的元素
要么都小于这个位置上的值（递增排序）,要么都大于该位置上的元素值（递减排序）。通
常选择这个初始元素,一般为第一个元素，当然可以随机的选择。可以看如下代码：

``` java
public class Quicksort{
    public static int quicks(int []arr,int high ,int low){
        int position = high;//低位
        int theOne = arr[high];
        while(high<=low){
            System.out.println(1);
            while (high<=low && arr[low]>theOne){
                low--; //高位变小
            }
            if (high<=low){

                arr[high] = arr [low];
                high++;
            }
            while(high<=low && arr[high]<theOne){
                high++;
            }
            if (high<=low){

                arr[low] = arr [high];
                low--;
            }
        }
        arr[low]=theOne;
        return low;
    }
    public static void quicksort(int []arr,int high, int low){
        int position =0;
        int a = 0;
        if (high < low){
        position = quicks(arr,high,low);
        quicksort(arr,high,position-1);
        quicksort(arr,position+1,low);

        }
        return ;
    }
    public static void prin(int []arr){
    
        for (int i = 0; i < arr.length; i++) {

            System.out.print(arr[i] + " ");
            
        }
    }
    public static void main (String[] args) {
        // int []arr = new int[]{5,3,7,4,9,2,8};
        int []arr1 = new int[]{5,5,5,5,5,5,5,4};
        int high = 0;
        int low = arr1.length-1;
        quicksort(arr1,high,low); 
        prin(arr1);
        // for (int i = 0; i < arr.length; i++) {
            // System.out.println(arr[i]);
        // }
    }
} 

```

### Shell排序

在简单排序中介绍了直接插入排序，那直接插入排序和Shell排序它们之间的关系是什么呢
。Shell 排序为什么能够达到排序的时间效率是O(Nlog(N))。Shell 排序也是一种插入排
序，它之所以比直接插入排序的效率高的原因它采用的是分组插入排序，对待排序的数据
，先分组然后是每一组数据使用直接插入排序法。而这个分组与直接插入排序对比优势就
体现出来了，而分组也是影响排序效率的最直接的原因了；一般为了方便程序的实现采用
的分组策略是折半分组，如元素个数为10时我们的分组可以是(5,2,1)，所有的分组最终都
会到1，这样把之前局部的分组有序使得在分组长度为1时重新做到全局有序。如下是代码
：

``` java
public class Shellsort{
    public static void main (String[] args) {
        int []a = new int[]{5,3,7,4,9,2,8};
        // int []a = new int[]{1,1,1,1,1,1,0};
        // int []a = new int[]{0,1,1,1,1,1,1};
        for(int gap = a.length/2; gap > 0 ; gap = gap/2){
            for (int j=gap; j<a.length; j++){
                if (a[j]<a[j-gap]){
                    int temp = a[j];
                    int k = j-gap;
                    while(k>=0 && a[k]>temp){
                        a[k+gap]=a[k];
                        k-=gap;
                    }
                    a[k+gap] = temp;
                }
            }
        }
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i]+" ");
        }
    }
} 

```

