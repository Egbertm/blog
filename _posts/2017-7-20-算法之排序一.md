---
layout: post
title:  "算法之排序一"
date: 2017-07-20 20:16:25
categories: 算法
tags:  排序
---
* content
{:toc}  
  
排序算法是数据结构这么课程中着重讲的，我们常常说的八大排序算法，也就是内排序算
法，有冒泡，选择，插入，希尔，快速，合并，基(桶)。博客分三篇分别把这几种排序算
法理一理。给出实现代码。




### 冒泡排序

对于冒泡排序，它的时间复杂度是O(N^2),空间复杂度为O(1),算法的思想就是对于任何一
个外层点，需要和内层的每个节点比较，在外层比较过后可以不用比较，也就是O(n*(n-1)/2)次数，因此它的时间复杂度是O(N^2)。

``` java

public class Bublesort{

    public static void sort(int []a){

        if (a == null || a.length<=0){
        
            return ;
        }
        int temp = 0;
        for (int i = 0; i < a.length; i++) {
            for (int j=i+1; j<a.length; j++){
            
                if (a[j]<a[i]){
                    temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
                    
                }
            }
            
        }
    }
    public static void main (String[] args) {
       int []a = new int []{5,3,7,4,2,9,8}; 
       sort(a);
       for (int i = 0; i < a.length; i++) {
           System.out.println(a[i]);
       }
    }
} 


```
### 插入排序

插入排序它的时间复杂度是O(N^2),空间复杂度是O(1),对于插入排序算法的思想是：

1) 从第一个元素开始，该元素可以认为已经被排序
2) 取出第一个未排序元素存放在临时变量temp中，在已经排序的元素序列中从后往前扫描，逐一比较
3) 如果temp小于已排序元素，将该元素移到下个位置
4) 重复步骤3〉，直到找到已排序的元素小于或者等于

``` java

public class Directsort{
    public static void sort(int []a){
        if (a == null || a.length<=0){
            return;
        }
        int i = 0;
        int num = a[i];
        for (int j = 1; j<a.length; j++){
            i = j-1;
            num = a[j];
            while(i>=0){
                if (num<a[i]){
                    a[i+1]=a[i];
                    i--;
                }else{
                    break;
                }
            }
            a[i+1]=num;
        }
    }
    public static void main (String[] args) {
        int []a = new int[]{5,3,7,4,9,2,8};
        sort(a);
        for (int i = 0; i < a.length; i++) {

            System.out.println(a[i]);
        }

        int []b=null;
        sort(b);
        
    }
} 


```

### 选择排序

选择排序它的时间复杂度是O(N^2)，空间复杂度是O(1);对于选择排序它的思想是：
首先选择第一个元素作为首元素，并认为它是最小的（或是最大的）;
对剩下的元素（第二层循环）遍历寻找比它小的元素，外层循环一趟下来得到了数组中的
最小或者是最大的元素，外层N趟之后，数组排好序。

``` java

public class Selectsort{

    public static void sort(int []a){
    
        int temp = 0;
        int index = -1;
        for (int i = 0;i<a.length;i++){
        
            temp = a[i];
            index = i;
            for(int j = i+1;j<a.length;j++){
            
                if (temp > a[j]){
                    temp = a[j];
                    index = j;
                }

            }
        a[index] = a[i];
        a[i] = temp;
        }
    }
    public static void main (String[] args) {
        int []a = new int[]{5,3,7,4,2,9,8};
        sort(a);

        for (int i = 0; i < a.length; i++) {

            System.out.println(a[i]);
            
        }
        
    }
} 

```

