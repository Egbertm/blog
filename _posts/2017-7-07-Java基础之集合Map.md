---
layout: post
title:  "Java基础之集合Hash" 
date: 2017-07-01 21:05:28
categories:
tags:  tags
---
* content
{:toc}  
  
上一篇文档中已经提到了集合的List框架，然而在整个大的集合框架中还有一个也是经常用
到的，这就是Map框架了。在程序中经常需要存储一些类似与<K,V>这样的数据了，那么我们
就很有必要了解一下Map框架了。





### Map框架概述

先看一张Java Map的框架图，可以有个大致的了解了。

``` java

                                          +----------------+
                     Iteraor              |                |
                        |                 |   collections  |
                        |                 |     Arrays     |
                        +--Collection     |                |
                              |           +----------------+
                              +---Map
                                   |               +-------------+
                  AbstractMap------+               |  Comporable |
                       |           |               +-------------+
                       |           |                      ^
             HashMap---+           +---SortedMap          |
                       |                |                 v
  ConCurrentHashMap----|                |          +-------------+
                       +-----------TreeMap         |  Comparator |
                       |                           +-------------+
                       +-----------HashTable  
                       |
         WeakHashMap---+

```

### 简单介绍

**Map接口**

Map是一个HashMap,TreeMap的顶级接口，扩展该接口的还有一个抽象类AbstractMap。我们
知道Map它存储的是对象是键值对的形式，也就是是说我们可以通过某个Key值，直接获得我
们需要的对象。那么它内部实现是基于什么样的数据结构呢？稍后详细介绍一下HashMap,这
个接口提供了一些方法的描述，如：Empty判断哈希表是否为空，Size的哈希表的长度，
containsKey,containsValue分别表示该哈希表是否包含对应的Key和Value等等，当然在接
口中也声明了equals和hashCode这两个方法。

**HashMap**

HashMap充分考虑到数组和链表各自的特点，取两者的优点：数组是对于查找方便对对象的
插入和删除困难，而对于链表而言其插入和删除方便而查找需要遍历比较困难；因此在此基
础上，设计如下图所示的Hash表的一中数据结构，它既能够易于查找，同时对于插入和删除
也有比较好的性能。我们称之为**链表的数组**。在HashMap里面他其实是一个线性的数组
实现的，内部有一个静态的前提类Node<K,V> 它有K,V,及next属性指向下一个Node节点。
`transient Node<K,V>[] table;`都存储在这个table表中。

``` java
           
   +-------+
   |       |   +----+--+   +---+---+   +--+-+---+
   |Entry| |-->| Entry||-->| Entry||-->| Entry| |-->
   |       |   +-------+   +-------+   +--------+
   +-------+
   |       |
   |Entry| |
   |       |
   +-------+
   |       |    +------+-+
   |Entry| |--> | Entry| |--->
   |       |    +--------+
   +-------+
   |       |
   |Entry| |
   |       |
   +-------+
   |       |    +-------+
   |Entry| |--->| Entry| |--->
   |       |    +-------+
   +-------+
```

**HashTable**

Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。HashTable
是一个线程安全的，它的方法多加上了同步关键字；不过现在也被弃用了，与它相似的是
Collections中的synchronizedMap方法，当然在Jdk1.5以后集合框架中加入了Current包，
里面提供了ConcurrentHashMap能够实现高效的多线程下的Hash表。

**TreeMap**

TreeMap 根据特定的排序规则存储的一组<K,V>集合，它采用的是红黑树的结构存储数据，
有点是存储的数据具有某种顺序，遍历之后输出的是有序的集合,它可以提供了如：
descendingMap,descendingKeySet分别获得排序的Map和排序的Key。

**ConCurrentHashMap**

ConcurrentHashMap通常只被看做并发效率更高的Map，用来替换其他线程安全的Map容器，
比如Hashtable和Collections.synchronizedMap。

**WeakHashMap**

键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有
map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。

### HashMap 和 HashTable


HashTable和HashMap区别
一、继承的父类不同
Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。

二、线程安全性不同
Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。
在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用
HashMap时就必须要自己增加同步处理。

三、是否提供contains方法
HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。
Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。

四、key和value是否允许null值
其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。
Hashtable中，key和value都不允许出现null值。
HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。
当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。
因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

五、两个遍历方式的内部实现上不同
Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

六、hash值不同
哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。

七、内部实现使用的数组初始化和扩容方式不同
Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数
组默认大小是11，增加的方式是 old*2+1。
HashMap中hash数组的默认大小是16，而且一定是2的指数。

### HashMap 和 TreeMap

1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，
如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。
HashMap中元素的排列顺序是不固定的）。

2、集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。

3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序
遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。
这个TreeMap没有调优选项，因为该树总处于平衡状态。

测试：
在hashMap中，同样的值的map,顺序不同，equals时，false;
而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。

### HashMap 和 ConCurrentHashMap

ConCurrentHashMap 内部存储的结构图如下：

``` java

                 +-----+                                             
                 |     |        +-------+        +-------+           
                 |     |------->| Entry |------->| Entry |         
                 |     |        +-------+        +-------+           
               />+-----+                                             
              /  |     |                                             
             /   |     |------->                                     
            /    |     |                                             
           /     +-----+                                             
     Segment                                                          
           \                                                         
            \    +-----+                                             
             \   |     |                                             
              \  |     |------->                                     
               \ |     |                                             
                >+-----+                                             
                 |     |        +-------+        +-------+           
                 |     |------->| Entry |------->| Entry |         
                 |     |        +-------+        +-------+           
                 +-----+                                             
           
```

1. 就像上面所说他们之间的第一个重要的区别就是ConcurrentHashMap是线程安全的和在
并发环境下不需要加额外的同步。虽然它不像Hashtable那样需要同样的同步等级(全表锁)
，但也有很多实际的用途。 

2.你可以使用Collections.synchronizedMap(HashMap)来包装HashMap作为同步容器，这时
它的作用几乎与Hashtable一样,当每次对Map做修改操作的时候都会锁住这个Map对象，而
ConcurrentHashMap会基于并发的等级来划分整个Map来达到线程安全，它只会锁操作的那
一段数据而不是整个Map都上锁。 

3. ConcurrentHashMap有很好的扩展性，在多线程环境下性能方面比做了同步的HashMap要
好，但是在单线程环境下，HashMap会比ConcurrentHashMap好一点。 

### ConcurrentHashMap 和 Hashtable 和 Synchronized Map 

虽然三个集合类在多线程并发应用中都是线程安全的，但是他们有一个重大的差别，就是他
们各自实现线程安全的方式。Hashtable是jdk1的一个遗弃的类，它把所有方法都加上
synchronized关键字来实现线程安全。所有的方法都同步这样造成多个线程访问效率特别低。
Synchronized Map与HashTable差别不大，也是在并发中作类似的操作，两者的唯一区别就是
Synchronized Map没被遗弃，它可以通过使用Collections.synchronizedMap()来包装Map作
为同步容器使用。
 
另一方面，ConcurrentHashMap的设计有点特别，表现在多个线程操作上。它不用做外的同步
的情况下默认同时允许16个线程读和写这个Map容器。因为其内部的实现剥夺了锁，使它有很
好的扩展性。不像HashTable和Synchronized Map，ConcurrentHashMap不需要锁整个Map，相
反它划分了多个段(segments)，要操作哪一段才上锁那段数据。


